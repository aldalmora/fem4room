import numpy as np
import scipy.signal as signal
import scipy.fft as fft
import pickle as pk
import gmsh
import numpy.linalg as la

class Sources():
    @staticmethod
    def monopole_factor(r,v,rho,is2D=True):
        """ Return the multiplying factor of the forcing function of a monopole based in a sphere of radius r and surface velocity v. """
        if is2D:
            Q = 2*np.pi*r*v #Unverified
        else:
            Q = 4*np.pi*(r**2)*v
        return rho * Q

    @staticmethod
    def space_gaussian_sinus(omega,c,x,y,z,x0,y0,z0,sigma_s):
        """ Return a gaussian in 3D space modulated by a sinusoid. """
        space_2 = (x-x0)**2 + (y-y0)**2 + (z-z0)**2
        exp_s = np.exp(-space_2/(2*sigma_s**2))
        factor = 1/(sigma_s*np.sqrt(2*np.pi))
        term_sin = np.sin(omega*np.sqrt(space_2)/c)
        return factor * term_sin * exp_s

    @staticmethod
    def space_gaussian(x,y,z,x0,y0,z0,sigma_s):
        """ Return a gaussian in 3D space. """
        space_2 = (x-x0)**2 + (y-y0)**2 + (z-z0)**2
        exp_s = np.exp(-space_2/(2*sigma_s**2))
        factor = 1/(sigma_s*np.sqrt(2*np.pi))
        return factor * exp_s

    @staticmethod
    def time_gaussian_sinus(t,omega,sigma_t,derivative=False):
        """ Return a 1D gaussian modulated by a sinusoid. If derivative=True returns the derivative of this function. """
        exp_t = np.exp(-t**2/(2*sigma_t**2))
        factor = 1/(sigma_t*np.sqrt(2*np.pi))
        if derivative:
            inner_t = omega*np.cos(omega*t) - t*np.sin(omega*t)/(sigma_t**2)
        else:
            inner_t = np.sin(omega*t)
        return factor * exp_t * inner_t

    @staticmethod
    def time_butter(fs,band,tSize):
        """ Return a signal generated by the Butterworth filter of order 2. """
        #dt = 1/fs
        #tSize = int(np.floor(length/dt/1024)) * 1024 
        b,a = signal.butter(2, band, 'bandpass', fs=fs)
        retFreqz = signal.freqz(b,a,fs=fs,worN=tSize,whole=True)
        signal_time = fft.irfft(retFreqz[1],tSize)
        return signal_time

class Visualization():
    @staticmethod
    def addView(mesh,viewName,timeData,nodeTags):
        """timeData must be (Timesteps)x(#ddl)"""
        viewTag = mesh.pos.add(viewName)
        for i_timeData in range(0,len(timeData)):
            mesh.pos.addModelData(viewTag,i_timeData,mesh.name,'NodeData',nodeTags,timeData[i_timeData].reshape(-1,1),numComponents=1)

    @staticmethod
    def showTime(mesh,viewNames,data,view_ddls,fltkrun=True):
        """data must be (Views)x(Timesteps)x(#ddl)"""
        for i_view in range(0,len(data)):
            nodeTags = mesh.nodeTags[view_ddls[i_view]]
            timeData = data[i_view]
            Visualization.addView(mesh,viewNames[i_view],timeData,nodeTags)

        if (fltkrun):
            mesh.FLTKRun()

class SaveLoad():
    def save(self,name,saved_ddls,ddl,sln,sln_main,tspan):
        """Save the mesh and the main infos about the numerical result."""
        self.ddl = ddl
        self.sln = sln
        self.sln_main = sln_main
        self.tspan = tspan
        self.saved_ddls = saved_ddls
        gmsh.option.setNumber('Mesh.SaveAll',1)
        gmsh.write('data/' + name + '.msh')
        with open('data/' + name + '.pickle', 'wb') as f:
            pk.dump(self, f, pk.HIGHEST_PROTOCOL)

    def load(self,name,m):
        """Load the mesh and the main infos about a numerical result."""
        gmsh.open('data/' + name + '.msh')
        m.readMsh('data/' + name + '.msh')
        with open('data/' + name + '.pickle', 'rb') as f:
            T = pk.load(f)
            self.ddl = T.ddl
            self.sln = T.sln
            self.sln_main = T.sln_main
            self.tspan = T.tspan
            self.saved_ddls = T.saved_ddls

class Other():
    @staticmethod
    def nearest_ddl(ddls,x):
        """Return the index of the nearest 3D degree of freedom"""
        idx = np.argmin(la.norm(ddls - x,axis=1))
        return idx